#!/bin/bash
# -*- sh -*-

: << =cut

=head1 NAME

  oracle_sysstat_* - Munin plugin to monitor Oracle Statistics

    cursor               - To monitor Oracle Sysstat Open Cursor
    execute              - To monitor Oracle Sysstat Execute Count
    parse                - To monitor Oracle Sysstat Parse Count
    sort                 - To monitor Oracle Sysstat Sorts
    tablescan            - To monitor Oracle Sysstat Table Scans
    transaction          - To monitor Oracle Sysstat Transactions
    enqueue              - To monitor Oracle Sysstat Enqueues
    redolog              - To monitor Oracle Sysstat Redo Log
    physicaliops         - To monitor Oracle Sysstat Physical I/O Requests
    physicalrw           - To monitor Oracle Sysstat Physical Read/Write
    sgainfo              - To monitor Oracle Memory SGA
    pgastat              - To monitor Oracle Memory PGA
    cachehit             - To monitor Oracle Cache Hit Ratio
    tablespace           - To monitor Oracle Table Space Usage
    sessionuser          - To monitor Oracle Session Users
    sessionwait          - To monitor Oracle Session Wait
    eventwait            - To monitor Oracle Wait Events
    eventwaitapplication - To monitor Oracle Wait Events Application
    eventwaitconcurrency - To monitor Oracle Wait Events Concurrency
    eventwaituserio      - To monitor Oracle Wait Events User I/O
    eventwaitsystemio    - To monitor Oracle Wait Events System I/O
    eventwaitcluster     - To monitor Oracle Wait Events Cluster
    asmusage             - To monitor Oracle ASM Disk Group Usage

=head1 CONFIGURATION

  To get a list of symlinks that can be created, run:   

    ./oracle_sysstat_ suggest

  Make symlinks:

    munin-node-configure --families=contrib --suggest --shell
    ...

  The following shows example settings for this plugin:

    [oracle_sysstat_*]
      user  oracle
      env.oracle_auth  / as SYSDBA
      env.ORACLE_HOME  /path/to/oracle/product/version
      env.ORACLE_SID   SOMESID

    [oracle_sysstat_asmusage]
      user  grid
      env.oracle_auth  / as SYSASM
      env.ORACLE_HOME  /path/to/grid/home/version
      env.ORACLE_SID   SOMESID

=head1 NOTES

  Uses the command "sqlplus".
  Tested with Oracle Database 12c R1.

=head1 AUTHOR

  K.Cima https://github.com/shakemid

=head1 LICENSE

  GPLv2

=cut

# Magic markers
#%# family=contrib
#%# capabilities=autoconf suggest

# Include plugin.sh
. $MUNIN_LIBDIR/plugins/plugin.sh

# Like perl 'use strict;' 
#set -o nounset

# Environments
: ${ORACLE_HOME:=$( echo /opt/oracle/product/* )}
: ${ORACLE_SID:=orcl}
: ${oracle_auth:=/ as SYSDBA}

PATH=$PATH:$ORACLE_HOME/bin
export PATH ORACLE_HOME ORACLE_SID

# Module name
module=$( basename $0 | sed -e 's/^.*_//' )

# Graph settings
declare -A global_attrs  # required
declare -A data_attrs    # required (format: field type draw 'label')
declare -A getfield_func # optional
declare -A getvalue_func # required

key=cursor
global_attrs[$key]="\
    graph_title Oracle Sysstat Open Cursors
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count
    graph_info Oracle Sysstat Open Cursors
"
data_attrs[$key]="\
    open_cursor GAUGE LINE 'opened cursors current'
"
getvalue_func[$key]=getvalue_sysstat

key=execute
global_attrs[$key]="\
    graph_title Oracle Sysstat Execute Count
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count per second
    graph_info Oracle Sysstat Execute Count
"
data_attrs[$key]="\
    execute_count    DERIVE LINE 'execute count'
    user_calls       DERIVE LINE 'user calls'
    recursive_calls  DERIVE LINE 'recursive calls'
"
getvalue_func[$key]=getvalue_sysstat

key=parse
global_attrs[$key]="\
    graph_title Oracle Sysstat Parse Count
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count per second
    graph_info Oracle Sysstat Parse Count
"
data_attrs[$key]="\
    parse_count_total     DERIVE LINE 'parse count (total)'
    parse_count_hard      DERIVE LINE 'parse count (hard)'
    parse_count_failures  DERIVE LINE 'parse count (failures)'
    parse_count_describe  DERIVE LINE 'parse count (describe)'
"
getvalue_func[$key]=getvalue_sysstat

key=physicaliops
global_attrs[$key]="\
    graph_title Oracle Sysstat Physical I/O Requests
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel iops
    graph_info Oracle Sysstat Physical I/O Requests
"
data_attrs[$key]="\
    physical_read_total        DERIVE LINE2 'physical read total IO requests'
    physical_read              DERIVE LINE  'physical read IO requests'
    physical_read_total_multi  DERIVE LINE  'physical read total multi block requests'
    physical_write_total       DERIVE LINE2 'physical write total IO requests'
    physical_write             DERIVE LINE  'physical write IO requests'
    physical_write_total_multi DERIVE LINE  'physical write total multi block requests'
"
getvalue_func[$key]=getvalue_sysstat

key=physicalrw
global_attrs[$key]="\
    graph_title Oracle Sysstat Physical Read/Write
    graph_category db
    graph_args --base 1024 --lower-limit 0 --rigid
    graph_vlabel bytes per second
    graph_info Oracle Sysstat Physical Read/Write
"
data_attrs[$key]="\
    physical_read_total  DERIVE LINE2 'physical read total bytes'
    physical_read        DERIVE LINE  'physical read bytes'
    physical_write_total DERIVE LINE2 'physical write total bytes'
    physical_write       DERIVE LINE  'physical write bytes'
"
getvalue_func[$key]=getvalue_sysstat

key=sort
global_attrs[$key]="\
    graph_title Oracle Sysstat Sorts
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count per second
    graph_info Oracle Sysstat - Sorts
"
data_attrs[$key]="\
    sorts_memory DERIVE LINE 'sorts (memory)'
    sorts_disk   DERIVE LINE 'sorts (disk)'
"
getvalue_func[$key]=getvalue_sysstat

key=tablescan
global_attrs[$key]="\
    graph_title Oracle Sysstat Table Scans
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count per second
    graph_info Oracle Sysstat Table Scans
"
data_attrs[$key]="\
    table_scans_short_tables DERIVE LINE 'table scans (short tables)'
    table_scans_long_tables  DERIVE LINE 'table scans (long tables)'
"
getvalue_func[$key]=getvalue_sysstat

key=transaction
global_attrs[$key]="\
    graph_title Oracle Sysstat Transactions
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count per second
    graph_info Oracle Sysstat Transactions
"
data_attrs[$key]="\
    user_commits   DERIVE LINE 'user commits'
    user_rollbacks DERIVE LINE 'user rollbacks'
"
getvalue_func[$key]=getvalue_sysstat

key=enqueue
global_attrs[$key]="\
    graph_title Oracle Sysstat Enqueues
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count per second
    graph_info Oracle Sysstat Enqueues
"
data_attrs[$key]="\
    enqueue_requests    DERIVE LINE 'enqueue requests'
    enqueue_releases    DERIVE LINE 'enqueue releases'
    enqueue_conversions DERIVE LINE 'enqueue conversions'
    enqueue_waits       DERIVE LINE 'enqueue waits'
    enqueue_timeouts    DERIVE LINE 'enqueue timeouts'
    enqueue_deadlocks   DERIVE LINE 'enqueue deadlocks'
"
getvalue_func[$key]=getvalue_sysstat

key=redolog
global_attrs[$key]="\
    graph_title Oracle Sysstat Redo Log
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count per second
    graph_info Oracle Sysstat Redo Log
"
data_attrs[$key]="\
    redo_entries                   DERIVE LINE 'redo entries'
    redo_buffer_allocation_retries DERIVE LINE 'redo buffer allocation retries'
    redo_log_space_requests        DERIVE LINE 'redo log space requests'
"
getvalue_func[$key]=getvalue_sysstat

key=sgainfo
global_attrs[$key]="\
    graph_title Oracle Memory SGA
    graph_category db
    graph_args --base 1024 --lower-limit 0 --rigid
    graph_vlabel bytes
    graph_info Oracle Memory SGA
"
data_attrs[$key]="\
    maximum_sga_size    GAUGE LINE      'Maximum SGA Size'
    fixed_sga_size      GAUGE AREASTACK 'Fixed SGA Size'
    redo_buffers        GAUGE AREASTACK 'Redo Buffers'
    shared_pool_size    GAUGE AREASTACK 'Shared Pool Size'
    large_pool_size     GAUGE AREASTACK 'Large Pool Size'
    java_pool_size      GAUGE AREASTACK 'Java Pool Size'
    streams_pool_size   GAUGE AREASTACK 'Streams Pool Size'
    shared_io_pool_size GAUGE AREASTACK 'Shared IO Pool Size'
    buffer_cache_size   GAUGE AREASTACK 'Buffer Cache Size'
    in_memory_area_size GAUGE AREASTACK 'In-Memory Area Size'
"
getvalue_func[$key]=getvalue_sgainfo

key=pgastat
global_attrs[$key]="\
    graph_title Oracle Memory PGA
    graph_category db
    graph_args --base 1024 --lower-limit 0 --rigid
    graph_vlabel bytes
    graph_info Oracle Memory PGA
"
data_attrs[$key]="\
    pga_target    GAUGE LINE 'aggregate PGA auto target'
    pga_allocated GAUGE LINE 'total PGA allocated'
    pga_inuse     GAUGE AREA 'total PGA inuse'
"
getvalue_func[$key]=getvalue_pgastat

key=cachehit
global_attrs[$key]="\
    graph_title Oracle Cache Hit Ratio
    graph_category db
    graph_args --base 1000 --lower-limit 0 --upper-limit 100 --rigid
    graph_vlabel %
    graph_info Oracle Cache Hit Ratio
    graph_scale no
"
data_attrs[$key]="\
    buf_hitratio  GAUGE LINE 'Buffer Cache Hit Ratio'
    lib_hitratio  GAUGE LINE 'Library Cache Hit Ratio'
    dict_hitratio GAUGE LINE 'Dictionary Cache Hit Ratio'
"
getvalue_func[$key]=getvalue_cachehit

key=tablespace
global_attrs[$key]="\
    graph_title Oracle Table Space Usage
    graph_category db
    graph_args --base 1000 --lower-limit 0 --upper-limit 100 --rigid
    graph_vlabel %
    graph_info Oracle Table Space Usage
    warning ${warning:=92}
    critical ${critical:=98}
"
data_attrs[$key]=""
getfield_func[$key]=getfield_tablespace
getvalue_func[$key]=getvalue_tablespace

key=asmusage
global_attrs[$key]="\
    graph_title Oracle ASM Disk Group Usage
    graph_category db
    graph_args --base 1000 --lower-limit 0 --upper-limit 100 --rigid
    graph_vlabel %
    graph_info Oracle ASM Disk Group Usage
    warning ${warning:=92}
    critical ${critical:=98}
"
data_attrs[$key]=""
getfield_func[$key]=getfield_asmusage
getvalue_func[$key]=getvalue_asmusage

key=sessionuser
global_attrs[$key]="\
    graph_title Oracle Session Users
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count
    graph_info Oracle Session Users
"
data_attrs[$key]=""
getfield_func[$key]=getfield_sessionuser
getvalue_func[$key]=getvalue_sessionuser

key=sessionwait
global_attrs[$key]="\
    graph_title Oracle Session Wait
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel count
    graph_info Oracle Session Wait
"
data_attrs[$key]=""
getfield_func[$key]=getfield_sessionwait
getvalue_func[$key]=getvalue_sessionwait

key=eventwait
global_attrs[$key]="\
    graph_title Oracle Wait Events
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel microseconds
    graph_info Oracle Wait Events
"
data_attrs[$key]=""
getfield_func[$key]=getfield_eventwait
getvalue_func[$key]=getvalue_eventwait

key=eventwaitconcurrency
global_attrs[$key]="\
    graph_title Oracle Wait Events Concurrency
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel microseconds
    graph_info Oracle Wait Events Concurrency
"
# memo: select event from v$system_event where wait_class = 'Concurrency' order by event;
data_attrs[$key]="\
    buffer_busy_waits                DERIVE LINE 'buffer busy waits'
    cursor_mutex_s                   DERIVE LINE 'cursor: mutex S'
    cursor_mutex_x                   DERIVE LINE 'cursor: mutex X'
    cursor_pin_s                     DERIVE LINE 'cursor: pin S'
    cursor_pin_s_wait_on_x           DERIVE LINE 'cursor: pin S wait on X'
    cursor_pin_x                     DERIVE LINE 'cursor: pin X'
    enq_tx_index_contention          DERIVE LINE 'enq: TX - index contention'
    latch_cache_buffers_chains       DERIVE LINE 'latch: cache buffers chains'
    latch_row_cache_objects          DERIVE LINE 'latch: row cache objects'
    latch_shared_pool                DERIVE LINE 'latch: shared pool'
    lck0_row_cache_object_free       DERIVE LINE 'LCK0 row cache object free'
    libcache_interrupt_action_by_lck DERIVE LINE 'libcache interrupt action by LCK'
    library_cache_load_lock          DERIVE LINE 'library cache load lock'
    library_cache_lock               DERIVE LINE 'library cache lock'
    library_cache_pin                DERIVE LINE 'library cache pin'
    library_cache_mutex_x            DERIVE LINE 'library cache: mutex X'
    resmgr_internal_state_change     DERIVE LINE 'resmgr:internal state change'
    row_cache_lock                   DERIVE LINE 'row cache lock'
"
getvalue_func[$key]=getvalue_eventwait2

key=eventwaitapplication
global_attrs[$key]="\
    graph_title Oracle Wait Events Application
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel microseconds
    graph_info Oracle Wait Events Application
"
# memo: select event from v$system_event where wait_class = 'Application' order by event;
data_attrs[$key]="\
    enq_ko_fast_object_checkpoint         DERIVE LINE 'enq: KO - fast object checkpoint'
    enq_pw_flush_prewarm_buffers          DERIVE LINE 'enq: PW - flush prewarm buffers'
    enq_rc_result_cache_contention        DERIVE LINE 'enq: RC - Result Cache: Contention'
    enq_ro_contention                     DERIVE LINE 'enq: RO - contention'
    enq_ro_fast_object_reuse              DERIVE LINE 'enq: RO - fast object reuse'
    enq_tm_contention                     DERIVE LINE 'enq: TM - contention'
    enq_tx_row_lock_contention            DERIVE LINE 'enq: TX - row lock contention'
    enq_ul_contention                     DERIVE LINE 'enq: UL - contention'
    external_procedure_call               DERIVE LINE 'External Procedure call'
    external_procedure_initial_connection DERIVE LINE 'External Procedure initial connection'
    olap_dml_sleep                        DERIVE LINE 'OLAP DML Sleep'
    repl_apply_apply_ddl                  DERIVE LINE 'REPL Apply: apply DDL'
    repl_capture_filter_callback_ruleset  DERIVE LINE 'REPL Capture: filter callback ruleset'
    sql_net_break_reset_to_client         DERIVE LINE 'SQL*Net break/reset to client'
    sql_net_break_reset_to_dblink         DERIVE LINE 'SQL*Net break/reset to dblink'
    wait_for_table_lock                   DERIVE LINE 'Wait for Table Lock'
    wcr_replay_lock_order                 DERIVE LINE 'WCR: replay lock order'
"
getvalue_func[$key]=getvalue_eventwait2

key=eventwaituserio
global_attrs[$key]="\
    graph_title Oracle Wait Events User I/O
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel microseconds
    graph_info Oracle Wait Events User I/O
"
# memo: select event from v$system_event where wait_class = 'User I/O' order by event;
data_attrs[$key]="\
    parameter_file_io       DERIVE LINE 'Parameter File I/O'
    disk_file_operations_io DERIVE LINE 'Disk file operations I/O'
    data_file_init_write    DERIVE LINE 'Data file init write'
    local_write_wait        DERIVE LINE 'local write wait'
    read_by_other_session   DERIVE LINE 'read by other session'
    db_file_sequential_read DERIVE LINE 'db file sequential read'
    db_file_scattered_read  DERIVE LINE 'db file scattered read'
    db_file_single_write    DERIVE LINE 'db file single write'
    db_file_parallel_read   DERIVE LINE 'db file parallel read'
    direct_path_read        DERIVE LINE 'direct path read'
    direct_path_read_temp   DERIVE LINE 'direct path read temp'
    direct_path_write       DERIVE LINE 'direct path write'
    direct_path_write_temp  DERIVE LINE 'direct path write temp'
    external_table_read     DERIVE LINE 'external table read'
    external_table_write    DERIVE LINE 'external table write'
    external_table_open     DERIVE LINE 'external table open'
"
getvalue_func[$key]=getvalue_eventwait2

key=eventwaitsystemio
global_attrs[$key]="\
    graph_title Oracle Wait Events System I/O
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel microseconds
    graph_info Oracle Wait Events System I/O
"
# memo: select event from v$system_event where wait_class = 'System I/O' or wait_class = 'Commit' order by event;
data_attrs[$key]="\
    control_file_parallel_write  DERIVE LINE 'control file parallel write'
    control_file_sequential_read DERIVE LINE 'control file sequential read'
    control_file_single_write    DERIVE LINE 'control file single write'
    db_file_async_io_submit      DERIVE LINE 'db file async I/O submit'
    db_file_parallel_write       DERIVE LINE 'db file parallel write'
    kfk_async_disk_io            DERIVE LINE 'kfk: async disk IO'
    log_archive_io               DERIVE LINE 'Log archive I/O'
    log_file_parallel_write      DERIVE LINE 'log file parallel write'
    log_file_sequential_read     DERIVE LINE 'log file sequential read'
    log_file_single_write        DERIVE LINE 'log file single write'
    log_file_sync                DERIVE LINE 'log file sync'
"
getvalue_func[$key]=getvalue_eventwait2

key=eventwaitcluster
global_attrs[$key]="\
    graph_title Oracle Wait Events Cluster
    graph_category db
    graph_args --base 1000 --lower-limit 0 --rigid
    graph_vlabel microseconds
    graph_info Oracle Wait Events Cluster
"
# memo: select event from v$system_event where wait_class = 'Cluster' order by event;
data_attrs[$key]="\
    gc_buffer_busy_acquire         DERIVE LINE 'gc buffer busy acquire'
    gc_buffer_busy_release         DERIVE LINE 'gc buffer busy release'
    gc_cr_block_2_way              DERIVE LINE 'gc cr block 2-way'
    gc_cr_block_busy               DERIVE LINE 'gc cr block busy'
    gc_cr_block_congested          DERIVE LINE 'gc cr block congested'
    gc_cr_block_lost               DERIVE LINE 'gc cr block lost'
    gc_cr_disk_read                DERIVE LINE 'gc cr disk read'
    gc_cr_failure                  DERIVE LINE 'gc cr failure'
    gc_cr_grant_2_way              DERIVE LINE 'gc cr grant 2-way'
    gc_cr_grant_congested          DERIVE LINE 'gc cr grant congested'
    gc_cr_multi_block_request      DERIVE LINE 'gc cr multi block request'
    gc_current_block_2_way         DERIVE LINE 'gc current block 2-way'
    gc_current_block_busy          DERIVE LINE 'gc current block busy'
    gc_current_block_congested     DERIVE LINE 'gc current block congested'
    gc_current_block_lost          DERIVE LINE 'gc current block lost'
    gc_current_grant_2_way         DERIVE LINE 'gc current grant 2-way'
    gc_current_grant_busy          DERIVE LINE 'gc current grant busy'
    gc_current_grant_congested     DERIVE LINE 'gc current grant congested'
    gc_current_multi_block_request DERIVE LINE 'gc current multi block request'
    gc_current_retry               DERIVE LINE 'gc current retry'
    gc_current_split               DERIVE LINE 'gc current split'
    gc_quiesce                     DERIVE LINE 'gc quiesce'
    gc_remaster                    DERIVE LINE 'gc remaster'
"
getvalue_func[$key]=getvalue_eventwait2

# End of Graph Settings

# sqlplus options
: ${sqlplus:=sqlplus}
: ${sqlplus_opts:=-S -L}
sqlplus_variables="\
    set pagesize 0
    set feed off
    set head off
    set linesize 256
    set numwidth 20
"

# functions 

autoconf() {
    if [ -x "$( which ${sqlplus} )" ]; then
        echo yes
    else
        echo "no (failed to find executable 'sqlplus')"
    fi
    exit 0
}

suggest() {
    echo ${!global_attrs[@]} | tr ' ' '\n' | sort
    exit 0
}

config() {
    # print global attributes
    sed -e 's/^  *//' -e '/^$/d' <<< "${global_attrs[$module]}"

    # print data source attributes
    local line t fields field type draw label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        fields+=( $field )
        type="${t[1]}"
        draw="${t[2]}"
        label="${t[3]}"

        echo ${field}.type  ${type}
        echo ${field}.draw  ${draw}
        echo ${field}.label ${label}
    done <<< "${data_attrs[$module]}"

    echo graph_order ${fields[@]}

    exit 0
}

getvalue() {
    ${getvalue_func[$module]}
    exit 0
}

getfield() {
    if [ -n "${getfield_func[$module]:-}" ]; then
        ${getfield_func[$module]}
    fi
}

getvalue_sysstat() {
    local line t field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[3]}"

        ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
VAR bv VARCHAR2(64)
EXEC :bv := '${label}' 
SELECT
  '${field}.value ' || value
FROM
  v\$sysstat
WHERE
  name = :bv;
EOF
    done <<< "${data_attrs[$module]}"
}

getvalue_sgainfo() {
    local line t field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[3]}"

        ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
VAR bv VARCHAR2(64)
EXEC :bv := '${label}' 
SELECT
  '${field}.value ' || bytes
FROM
  v\$sgainfo
WHERE
  name = :bv;
EOF
    done <<< "${data_attrs[$module]}"
}

getvalue_pgastat() {
    local line t field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[3]}"

        ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
VAR bv VARCHAR2(64)
EXEC :bv := '${label}' 
SELECT
  '${field}.value ' || value
FROM
  v\$pgastat
WHERE
  name = :bv;
EOF
    done <<< "${data_attrs[$module]}"
}

getfield_sessionuser() {
    local type_default=GAUGE
    local draw_default=LINE

    local line field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[1]}"

        data_attrs[$module]="${data_attrs[$module]}${field} ${type_default} ${draw_default} '${label}'"$'\n'
    done < <( exec ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( username, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) ||
  ' ''' || username || ''''
FROM
  dba_users
WHERE
  account_status = 'OPEN'
ORDER BY
  username;
EOF
)
}

getvalue_sessionuser() {
    ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( du.username, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) || '.value ' ||
  count(vs.username)
FROM 
  ( SELECT
      username
    FROM
      dba_users
    WHERE
      account_status = 'OPEN'
  ) du
  LEFT JOIN v\$session vs
ON
  du.username = vs.username
GROUP BY
  du.username;
EOF
}

getvalue_cachehit() {
    ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  'buf_hitratio.value ' || round( ( 1 - a.value / ( b.value + c.value ) ) * 100 )
FROM
  v\$sysstat a, v\$sysstat b, v\$sysstat c
WHERE
  a.name = 'physical reads' AND
  b.name = 'db block gets' AND
  c.name = 'consistent gets'
;
SELECT
  'lib_hitratio.value ' || round( sum(pins) / ( sum(pins) + sum(reloads) ) * 100 )
FROM
  v\$librarycache
;
SELECT
  'dict_hitratio.value ' || round( ( 1 - sum(getmisses) / sum(gets) ) * 100 )
FROM
  v\$rowcache
;
EOF
}

getfield_tablespace() {
    local type_default=GAUGE
    local draw_default=LINE

    local line field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[1]}"

        data_attrs[$module]="${data_attrs[$module]}${field} ${type_default} ${draw_default} '${label}'"$'\n'
    done < <( command ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( tablespace_name, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) ||
  ' ''' || tablespace_name || ''''
FROM
  dba_data_files
ORDER BY
  tablespace_name;
EOF
)
}

getvalue_tablespace() {
    ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( tablespace_name, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) || '.value ' ||
  round( (total_bytes - free_total_bytes) / total_bytes * 100, 0 )
FROM
  ( SELECT
      tablespace_name,
      sum(bytes) total_bytes
    FROM
      dba_data_files
    GROUP BY
      tablespace_name
  ),
  ( SELECT
      tablespace_name free_tablespace_name,
      sum(bytes) free_total_bytes
    FROM
      dba_free_space
    GROUP BY
      tablespace_name
  )
WHERE
  tablespace_name = free_tablespace_name;
EOF
}

getfield_asmusage() {
    local type_default=GAUGE
    local draw_default=LINE

    local line field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[1]}"

        data_attrs[$module]="${data_attrs[$module]}${field} ${type_default} ${draw_default} '${label}'"$'\n'
    done < <( command ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( name, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) ||
  ' ''' || name || ''''
FROM
  v\$asm_diskgroup
ORDER BY
  name;
EOF
)
}

getvalue_asmusage() {
    ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( name, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) || '.value ' ||
  round( ( total_mb - free_mb ) / total_mb * 100 )
FROM
  v\$asm_diskgroup
ORDER BY
  name;
EOF
}

getfield_sessionwait() {
    local type_default=GAUGE
    local draw_default=AREASTACK

    local line field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[1]}"

        data_attrs[$module]="${data_attrs[$module]}${field} ${type_default} ${draw_default} '${label}'"$'\n'
    done < <( command ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( wait_class, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) ||
  ' ''' || wait_class || ''''
FROM
  v\$event_name
WHERE
  wait_class NOT IN ( 'Other', 'Idle' )
GROUP BY
  wait_class
ORDER BY
  wait_class;
SELECT 'Other', 'Other' from dual;
SELECT 'Idle', 'Idle' from dual;
EOF
)
}

getvalue_sessionwait() {
    ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( en.wait_class, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) || '.value ' ||
  count(se.wait_class)
FROM
  ( SELECT
      wait_class
    FROM
      v\$event_name
    WHERE
      wait_class NOT IN ( 'Other', 'Idle' )
    GROUP BY
      wait_class
  ) en
  LEFT JOIN v\$session se
ON
  en.wait_class = se.wait_class AND 
  se.username is not null
GROUP BY
  en.wait_class
;
SELECT 
  'Other.value ' || count(wait_class)
FROM
  v\$session
WHERE
  wait_class = 'Other' AND username is not null
;
SELECT 
  'Idle.value ' || count(wait_class)
FROM
  v\$session
WHERE
  wait_class = 'Idle' AND username is not null
;
EOF
}

getfield_eventwait() {
    local type_default=DERIVE
    local draw_default=LINE

    local line field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[1]}"

        data_attrs[$module]="${data_attrs[$module]}${field} ${type_default} ${draw_default} '${label}'"$'\n'
    done < <( command ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( wait_class, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) ||
  ' ''' || wait_class || ''''
FROM
  v\$event_name
WHERE
  wait_class NOT IN ( 'Other', 'Idle' )
GROUP BY
  wait_class
ORDER BY
  wait_class;
SELECT 'Other', 'Other' from dual;
EOF
)
}

getvalue_eventwait() {
    ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
SELECT
  regexp_replace( en.wait_class, '^[^A-Za-z_]|[^A-Za-z0-9_]', '_' ) || '.value ' ||
  NVL( SUM(se.time_waited_micro), 0 )
FROM
  ( SELECT
      wait_class
    FROM
      v\$event_name
    WHERE
      wait_class NOT IN ( 'Other', 'Idle' )
    GROUP BY
      wait_class
  ) en
  LEFT JOIN v\$system_event se
ON
  en.wait_class = se.wait_class
GROUP BY
  en.wait_class
;
SELECT 
  'Other.value ' || NVL( SUM(time_waited_micro), 0 )
FROM
  v\$system_event
WHERE
  wait_class = 'Other'
;
EOF
}

getvalue_eventwait2() {
    local line t field label
    while read -r line
    do
        eval t=\( "$line" \)
        field="${t[0]}"
        [ -z "$field" ] && continue
        label="${t[3]}"

        ${sqlplus} ${sqlplus_opts} "${oracle_auth}" <<EOF
${sqlplus_variables}
VAR bv VARCHAR2(64)
EXEC :bv := '${label}' 
SELECT
  '${field}.value ' || NVL( se.time_waited_micro, 0 )
FROM
  v\$event_name en LEFT JOIN v\$system_event se
ON
  en.name = se.event
WHERE
  en.name = :bv;
EOF
    done <<< "${data_attrs[$module]}"
}

# main
case ${1:-} in
autoconf)
    autoconf
    ;;
suggest)
    suggest
    ;;
config)
    getfield
    config
    ;;
*)
    getfield
    getvalue
    ;;
esac
